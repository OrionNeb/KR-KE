---
lang: de  # Dokumentensprache: Deutsch

format:
  pdf:
    documentclass: book
    classoption: openany, oneside  # Kapitel auf jeder Seite starten (verhindert leere Seiten)
    mainfont: "Latin Modern Roman"
    fontsize: 11pt
    linestretch: 1.5  # Zeilenabstand auf 1,5 setzen (für bessere Lesbarkeit)
    code-fold: false  # Code-Chunks bleiben immer sichtbar (nicht einklappbar)
    toc: false
    toc-depth: 4
    number-sections: true
    unnumbered-sections: true
    geometry: "top=3cm, bottom=3cm, headheight=15pt, headsep=1.5cm, footskip=1.5cm"
    pdf-engine: lualatex
    listings: false
    highlight-style: tango  # Syntax-Highlighting für Code
    code-block-font-size: \tiny
    code-overflow: wrap
    include-in-header: 
      - setup/header.qmd
      - setup/glossar-eintraege.qmd
    include-before-body:
      - setup/titlepage.qmd
      - setup/gendererklaerung.qmd
      - setup/abstract.qmd
      - setup/verzeichnisse.qmd
      - setup/mainmatter.qmd
    include-after-body:
      - setup/glossar.qmd
      - setup/ehenwoertlicheErklaerung.qmd
  html:
    code-fold: true  # Code-Chunks in HTML können ausgeklappt werden
    toc: false
    toc-depth: 4
    number-sections: true
    self-contained: true  # Alle Ressourcen (Bilder, CSS, etc.) in einer Datei speichern
    math: mathjax
    other-formats: ["pdf", "docx", "pptx"]
  docx:
    toc: false
    number-sections: true
  pptx:
    reference-doc: setup/FHDW-Powerpoint-Vorlage_16zu9.pptx  # (Optional) Eigene Vorlage nutzen
bibliography: setup/references.yaml
citeproc: true
csl: setup/apa-with-abstract-de.csl # https://www.zotero.org/styles/apa-with-abstract
link-citations: true
link-bibliography: true
editor: source
execute:
  freeze: auto
  eval: true
  echo: true       # Code anzeigen
  results: markup  # Output als formatierten Text ausgeben
  warning: false   # Warnungen unterdrücken
  message: false   # Nachrichten (z. B. von Paketen) unterdrücken
  code-overflow: wrap  # Lange Zeilen umbrechen
---

```{r r-setup}

#| eval=TRUE
#| echo=TRUE
#| include=FALSE
#| results=TRUE
#| message=FALSE
#| warning=FALSE

# Arbeitsumgebung leeren (alle Objekte entfernen)
rm(list = ls())
gc()

# Root für Quarto setzen
knitr::opts_knit$set(root.dir = here::here())

# Installiere und lade erforderliche Bibliotheken
if (!requireNamespace("reticulate", quietly = TRUE)) install.packages("reticulate")
if (!requireNamespace("rmarkdown", quietly = TRUE)) install.packages("rmarkdown")
if (!requireNamespace("shiny", quietly = TRUE)) install.packages("shiny")
if (!requireNamespace("dplyr", quietly = TRUE)) install.packages("dplyr")
if (!requireNamespace("tidyr", quietly = TRUE)) install.packages("tidyr")
if (!requireNamespace("tidyverse", quietly = TRUE)) install.packages("tidyverse")
if (!requireNamespace("forecast", quietly = TRUE)) install.packages("forecast")
if (!requireNamespace("ggpubr", quietly = TRUE)) install.packages("ggpubr")
if (!requireNamespace("viridis", quietly = TRUE)) install.packages("viridis")




library(reticulate)
library(rmarkdown)
library(shiny)
library(dplyr)
library(tidyr)
library(tidyverse)
library(forecast)
library(ggpubr)
library(viridis)

```

```{python python-setup}

#| eval=TRUE
#| echo=TRUE
#| include=FALSE
#| results=TRUE
#| message=FALSE
#| warning=FALSE

# Erforderliche Bibliotheken installieren (falls nicht vorhanden)
import subprocess
import sys

def install_and_import(package):
    try:
        __import__(package)
    except ImportError:
        subprocess.check_call([sys.executable, "-m", "pip", "install", package])
    finally:
        globals()[package] = __import__(package)

# Äquivalente Bibliotheken in Python installieren und importieren
libraries = ["pandas", "numpy", "matplotlib", "seaborn", "scipy", "statsmodels", "pulp"]

for lib in libraries:
    install_and_import(lib)

# Bibliotheken laden
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy import stats
from statsmodels.tsa.seasonal import STL
from pulp import LpMaximize, LpProblem, LpVariable, value

```

<!-- ================= 1. Einleitung ================= -->

# Einleitung {#sec-einleitung}
<!--== Verantwortlich: Christian ==-->
<!--== Enthält 1.1 Problemstellung, 1.2 Zielsetzung, 1.3 Vorgehensweise ==-->

## Problemstellung {#sec-problemstellung}
Unternehmen müssen Risiken in komplexen Geschäftsprozessen frühzeitig erkennen und strukturiert bewerten. Klassische Methoden wie die Fehlermöglichkeits- und Einflussanalyse sind weit verbreitet, stoßen jedoch an Grenzen, wenn Abteilungen unterschiedliche Bewertungslogiken verwenden oder wenn Unsicherheiten in den Einschätzungen bestehen. Dadurch wird die Vergleichbarkeit von Risiken erschwert und die Entscheidungsfindung verliert an Transparenz.

## Zielsetzung {#sec-zielsetzung}
Diese Arbeit verfolgt das Ziel, ein wissensbasiertes Decision Support System nach den Grundsätzen der ISO 31000 zu entwickeln. Das System soll Wissen aus Risikoanalysen systematisch erfassen und mithilfe eines Fuzzy-Ansatzes um Unsicherheiten erweitern. Dadurch entsteht ein Modell, das Risiken nachvollziehbar bewertet und priorisierte Handlungsempfehlungen ermöglicht.

Im Mittelpunkt dieser Arbeit steht die Frage, wie Wissen aus Risikoanalysen mithilfe von Methoden des Knowledge Engineering in ein wissensbasiertes Decision Support System überführt werden kann, das Unsicherheiten berücksichtigt und priorisierte Handlungsempfehlungen ermöglicht.

## Vorgehensweise {#sec-vorgehensweise}
Die Arbeit folgt dem CRISP DM Vorgehensmodell. Der theoretische Teil stellt die Grundlagen des Risikomanagements, der FMEA Methode und der Wissensrepräsentation dar. Der praktische Teil beschreibt die Umsetzung in Python auf der Basis eines domänenübergreifenden FMEA Datensatzes. Die Ergebnisse werden verglichen und in einer strukturierten Wissensbasis dokumentiert. Eine Untersuchung zeigt, dass das zugrunde liegende Problem in der Literatur bereits beschrieben wurde. Andere Autoren kommen zu unterschiedlichen Einschätzungen.

<!-- ================= 2. Theoretischer Rahmen und Grundlagen ================= -->

# Theoretischer Rahmen und Grundlagen {#sec-theorie}
<!--== Verantwortlich: Christian – Nick liefert Fachquellen ==-->
<!--== Entspricht CRISP-DM Phase 1–2: Business & Data Understanding ==-->

## Grundlagen des Risikomanagements nach ISO 31000 {#sec-iso31000}
Erläuterung der Prinzipien, Ziele und Struktur der Norm sowie die Verbindung zwischen Risiko, Unsicherheit und Entscheidungsfindung.

## Fehlermöglichkeits- und Einflussanalyse (FMEA) {#sec-fmea}
Darstellung der Methode, Aufbau, Berechnung der Risikoprioritätszahl (RPN) und Grenzen klassischer FMEA-Ansätze.

## Knowledge Engineering und Wissensrepräsentation {#sec-ke}
Definition und Zielsetzung, Unterscheidung von implizitem und explizitem Wissen, 
sowie Einsatz von Ontologien, semantischen Netzen und RDF/JSON zur formalen Darstellung von Risiko-Wissen.

## Decision-Support-Systeme und Fuzzy-Logik {#sec-dss-fuzzy}
Grundlagen von DSS im Risikomanagement, Einführung in Fuzzy-Logik zur Abbildung unscharfer Bewertungen 
und Verknüpfung von FMEA, Fuzzy-Logik und Wissensrepräsentation.

<!-- ================= 3. Umsetzung des Modells ================= -->

# Umsetzung des Modells {#sec-umsetzung}
<!--== Verantwortlich: Nick (Daten & Technik), Christian (Wissenschaftliche Dokumentation) ==-->
<!--== Entspricht CRISP-DM Phase 3–6: Data Preparation, Modeling, Evaluation, Deployment ==-->

## Data Preparation {#sec-dataprep}
Aufbau und Beschreibung des domänenübergreifenden FMEA-Datensatzes. 
Darstellung der Bewertungsattribute, Skalen und Abteilungszuordnung. 
Begründung der Datenauswahl und Einbettung in reale Geschäftsprozesse.

## Modeling {#sec-modeling}
Entwicklung der Python-Pipeline `fmea_dss.py` zur automatisierten Bewertung von Risiken.  
Berechnung klassischer RPN-Werte, Integration der Fuzzy-Logik zur Abbildung von Unsicherheiten 
und Generierung einer Wissensrepräsentation in JSON/RDF.

## Evaluation {#sec-evaluation}
Vergleich klassischer und Fuzzy-basierter Risikoanalysen. 
Interpretation der Ergebnisse anhand der Top-Risiken und Risikoverläufe. 
Visualisierung der Resultate (Balkendiagramme, Heatmaps).

## Deployment {#sec-deployment}
Export der Wissensbasis (`knowledge.json`, RDF) und Integration der Ergebnisse 
in Entscheidungsprozesse. Reflexion des Nutzens für verschiedene Geschäftsdomänen.

<!-- ================= 4. Diskussion ================= -->

# Diskussion {#sec-diskussion}
<!--== Verantwortlich: Christian (Analytisch), Nick (Technische Reflexion) ==-->
Bewertung der Ergebnisse im Hinblick auf die Forschungsfrage. 
Darstellung des Mehrwerts wissensbasierter Fuzzy-FMEA-Modelle, 
Grenzen der Implementierung sowie Potenziale für zukünftige Anwendungen.



<!-- ================= 5. Fazit ================= -->

# Fazit und Ausblick {#sec-fazit}

## Beantwortung der Forschungsfrage

Die Forschungsfrage konnte beantwortet werden. Durch die Kombination von Knowledge Engineering und Fuzzy-Logik lassen sich Risikoanalysen strukturiert, nachvollziehbar und realitätsnah abbilden. Unsicheres Wissen wird dadurch für Computersysteme verständlich und auswertbar.

## Bewertung des Nutzens wissensbasierter Risikomodelle

Das entwickelte Konzept zeigt, dass wissensbasierte Modelle klassische FMEA-Ansätze deutlich erweitern. Sie fördern Wissenstransparenz, erhöhen die Entscheidungssicherheit und ermöglichen die Priorisierung von Risiken auf Grundlage formalisierter Regeln.

## Ausblick auf die Integration in unternehmensweite DSS und Ontologien

In Zukunft können solche Systeme in größere Entscheidungsplattformen integriert werden. Die Anbindung an Ontologien und semantische Netze eröffnet die Möglichkeit, Risiken nicht nur zu bewerten, sondern auch automatisch zu erkennen und vorbeugende Maßnahmen vorzuschlagen.

<!-- ================= Literaturverzeichnis ================= -->

# Literaturverzeichnis {.unnumbered}

::: {#refs}
:::
\pagestyle{literature}
\markboth{Literaturverzeichnis}{Literaturverzeichnis}

\clearpage

<!-- ================= Anhangsverzeichnis-Header ================= -->

::: {#sec-anhang}
# Anhang {.unnumbered}
:::
\markboth{Anhang}{Anhang} 
\thispagestyle{empty}
\renewcommand{\thefigure}{A.\arabic{figure}}
\setcounter{figure}{0}

*Hinweis:* Alle Abbildungen in den Anhängen tragen das Präfix **A** in ihrer Nummerierung. 
Das **A** verweist zugleich auf den Anhang und wird fortlaufend gezählt.


<!-- ================= Anhangsverzeichnis ================= -->

::: {#sec-anhangsverzeichnis}
## Anhangsverzeichnis {.unnumbered}
:::
\pagestyle{appendixTOC}
\noindent


**Anhang A** [Zero-Trust-Modell](#sec-anhangA) \dotfill  \pageref{sec-anhangA}

&nbsp;&nbsp;&nbsp;**A.1** [Zero-Trust-Säulen](#sec-anhangA.1) \dotfill  \pageref{sec-anhangA.1}

**Anhang B** [Erste Analyse der Daten](#sec-anhangB) \dotfill  \pageref{sec-anhangB}

&nbsp;&nbsp;&nbsp;**B.1** [Ergebnisse der ersten Analyse](#sec-anhangB.1) \dotfill  \pageref{sec-anhangB.1}
 





\clearpage

<!-- ================= Anhang ================= -->
\pagestyle{appendix} 
::: {#sec-anhangA}
# Anhang A: Zero-Trust-Modell {.unnumbered}
:::
\markboth{Anhang A: Zero-Trust-Modell}{}

\clearpage

::: {#sec-anhangA.1}
## A.1: Zero-Trust-Säulen {.unnumbered}
:::

\lorem
Laut einer Untersuchung von Mustermann [@internationalorganizationforstandardizationISO3100020182018] ist das Problem bekannt.

Andere Autoren sind anderer Meinung [@sauterDecisionSupportSystems2011].

\clearpage

::: {#sec-anhangB}
# Anhang B: Erste Analyse der Daten {.unnumbered}
:::
\markboth{Anhang B: Erste Analyse der Daten}{}

\lorem

\clearpage

::: {#sec-anhangB1}
## B1: Lorem {.unnumbered}
:::

\lorem









<!-- ================= Ende ================= -->
